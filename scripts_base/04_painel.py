# =============================================== # üéß SPIN Analyzer ‚Äî Painel (TXT + WAV) # Foco: UX profissional + robustez de sess√£o (Streamlit Cloud) # - Individual: abre o Excel principal + download do Excel # - Gerencial (lote): abre Excel consolidado + downloads (Excel lote + Excel por item) # - Progresso elegante (barra + tempo decorrido) # - Limites do lote: # ‚Ä¢ √Åudio: at√© 5 arquivos ‚Ä¢ at√© 10 minutos cada # ‚Ä¢ Texto: at√© 8 entradas (arquivos + blocos colados) # - Corre√ß√£o cr√≠tica: N√ÉO persiste bytes grandes em st.session_state # - Sem TXT: remove downloads e qualquer persist√™ncia de transcri√ß√£o # =============================================== import os import re import io import time import zipfile import wave import threading import uuid from datetime import datetime from pathlib import Path from typing import Optional, Tuple, List, Dict, Any import streamlit as st import pandas as pd import requests # ============================== # ‚öôÔ∏è set_page_config PRIMEIRO # ============================== st.set_page_config( page_title="SPIN Analyzer ‚Äî Avalia√ß√£o de Liga√ß√µes", page_icon="üéß", layout="wide", ) # ============================== # üîê Config (Secrets/Env) # ============================== def _get_cfg(key: str, default: str = "") -> str: v = os.getenv(key) if v is not None: return str(v).strip() try: if key in st.secrets: return str(st.secrets[key]).strip() except Exception: pass return str(default).strip() MODE = _get_cfg("MODE", "VPS").upper() BASE_URL = _get_cfg("VPS_BASE_URL", "").rstrip("/") API_KEY = _get_cfg("VPS_API_KEY", "") CONNECT_TIMEOUT_S = int(_get_cfg("CONNECT_TIMEOUT_S", "10")) READ_TIMEOUT_S = int(_get_cfg("API_TIMEOUT_S", "7200")) REQ_TIMEOUT = (CONNECT_TIMEOUT_S, READ_TIMEOUT_S) EXCEL_WRAP_TEXT = _get_cfg("EXCEL_WRAP_TEXT", "1").strip() not in ("0", "false", "False", "") EXCEL_DEFAULT_COL_W = int(_get_cfg("EXCEL_DEFAULT_COL_W", "22")) EXCEL_TEXT_COL_W = int(_get_cfg("EXCEL_TEXT_COL_W", "55")) EXCEL_MAX_COL_W = int(_get_cfg("EXCEL_MAX_COL_W", "80")) if MODE != "VPS": st.error("Este painel est√° configurado apenas para execu√ß√£o online. Ajuste a configura√ß√£o do projeto.") st.stop() if not BASE_URL: st.error("Configura√ß√£o ausente: endere√ßo do servi√ßo.") st.stop() if not API_KEY: st.error("Configura√ß√£o ausente: chave de acesso.") st.stop() # ============================== # üé® Estilo (visual limpo e consistente) # ============================== st.markdown( """ <style> :root{ --bg:#F6F8FC; --card:#FFFFFF; --text:#0B1220; --muted:#4B5A74; --line:#E5ECFA; --brand:#0B63F3; --ok:#17B26A; --warn:#F79009; --shadow: 0 10px 30px rgba(11,18,32,0.08); } html, body, [data-testid="stAppViewContainer"]{ background: var(--bg) !important; color: var(--text) !important; font-family: "Segoe UI", system-ui, -apple-system, Arial, sans-serif; } h1,h2,h3{ color: var(--text) !important; letter-spacing:-0.2px; } hr{ border-color: var(--line) !important; } .block-container{ padding-top: 1.25rem; padding-bottom: 2.5rem; } .card{ background: var(--card) !important; border: 1px solid var(--line) !important; border-radius: 18px; padding: 16px 18px; box-shadow: var(--shadow); } .card-tight{ background: var(--card) !important; border: 1px solid var(--line) !important; border-radius: 16px; padding: 12px 14px; box-shadow: var(--shadow); } .kicker{ font-size: 0.9rem; font-weight: 700; color: var(--muted); margin: 0 0 6px 0; } .title{ margin: 0; font-size: 1.15rem; font-weight: 800; color: var(--text); } .muted{ color: var(--muted); font-weight: 600; margin: 8px 0 0 0; } .badges{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; } .badge{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid var(--line); background:#FAFBFF; color: var(--muted); font-weight:800; font-size: 0.9rem; } .badge-ok{ border-color: rgba(23,178,106,0.25); background: rgba(23,178,106,0.10); color: #08603B; } .badge-brand{ border-color: rgba(11,99,243,0.25); background: rgba(11,99,243,0.08); color: #0B63F3; } .smallline{ font-size:0.95rem; color: var(--muted); font-weight: 650; } .stProgress > div > div > div > div{ border-radius: 999px !important; } div[data-testid="stAlert"]{ border-radius: 14px !important; } </style> """, unsafe_allow_html=True, ) # ============================== # üß† Estado (somente chaves pequenas) # ============================== def _ensure_state(): ss = st.session_state ss.setdefault("view", "single") # single | batch ss.setdefault("single_mode", "txt") # txt | wav ss.setdefault("batch_mode", "txt") # txt | wav ss.setdefault("processing", False) # IDs pequenos (resultados grandes ficam fora da sess√£o) ss.setdefault("single_result_id", "") ss.setdefault("batch_result_id", "") # Estimativas (leves) ss.setdefault("ema_txt_sec", None) ss.setdefault("ema_wav_sec", None) ss.setdefault("ema_batch_item_sec", None) # Guard de execu√ß√£o (leve): para detectar ‚Äúestava rodando mas caiu‚Äù ss.setdefault("run_token", "") ss.setdefault("run_started_at", 0.0) _ensure_state() # ============================== # üßØ Watchdog: se ‚Äúficou rodando‚Äù mas foi interrompido # ============================== RUN_STALE_WARN_SEC = 4 * 60 # 4 minutos (ajuste seguro) def _watchdog_ui(): ss = st.session_state if ss.get("processing") and ss.get("run_started_at"): elapsed = time.time() - float(ss["run_started_at"]) if elapsed > RUN_STALE_WARN_SEC: ss["processing"] = False ss["run_token"] = "" ss["run_started_at"] = 0.0 st.warning( "Parece que a execu√ß√£o foi interrompida antes de concluir (por exemplo, queda de conex√£o). " "Voc√™ pode iniciar novamente." ) _watchdog_ui() # ============================== # üß∫ Store em mem√≥ria (fora do session_state) # - Evita crash de sess√£o com bytes grandes. # - Evic√ß√£o simples para n√£o crescer infinito. # ============================== _STORE: Dict[str, Dict[str, Any]] = {} _STORE_ORDER: List[str] = [] _STORE_MAX = 40 # mant√©m as √∫ltimas ~40 execu√ß√µes def _store_put(payload: Dict[str, Any]) -> str: sid = uuid.uuid4().hex _STORE[sid] = payload _STORE_ORDER.append(sid) while len(_STORE_ORDER) > _STORE_MAX: old = _STORE_ORDER.pop(0) _STORE.pop(old, None) return sid def _store_get(sid: str) -> Optional[Dict[str, Any]]: if not sid: return None return _STORE.get(sid) def _store_del(sid: str) -> None: if not sid: return _STORE.pop(sid, None) try: _STORE_ORDER.remove(sid) except ValueError: pass def clear_single(): _store_del(st.session_state.get("single_result_id", "")) st.session_state["single_result_id"] = "" def clear_batch(): _store_del(st.session_state.get("batch_result_id", "")) st.session_state["batch_result_id"] = "" def clear_all(): clear_single() clear_batch() # ============================== # ‚úÖ Valida√ß√£o (cliente-friendly) # ============================== def validar_transcricao(txt: str) -> Tuple[bool, str]: linhas = [l.strip() for l in (txt or "").splitlines() if l.strip()] if len(linhas) < 4: return False, "O texto est√° muito curto para an√°lise. Cole uma conversa completa." if not any(re.match(r"^\[(VENDEDOR|CLIENTE)\]", l, re.I) for l in linhas): return False, "Use o formato com [VENDEDOR] e [CLIENTE] no in√≠cio de cada fala." return True, "ok" # ============================== # ‚è±Ô∏è Utilidades # ============================== def duracao_wav_seg_bytes(wav_bytes: bytes) -> float: try: bio = io.BytesIO(wav_bytes) with wave.open(bio, "rb") as wf: return wf.getnframes() / float(wf.getframerate()) except Exception: return 0.0 def human_time(sec: float) -> str: try: sec = float(sec) except Exception: sec = 0.0 sec = max(0.0, sec) if sec < 60: return f"{int(sec)}s" return f"{int(sec // 60)}m {int(sec % 60)}s" # ============================== # üìè Excel: formata√ß√£o leve # ============================== from io import BytesIO def format_excel_bytes(excel_bytes: bytes) -> bytes: if not excel_bytes: return excel_bytes try: from openpyxl import load_workbook from openpyxl.styles import Alignment except Exception: return excel_bytes bio = BytesIO(excel_bytes) wb = load_workbook(bio) ws = wb.active ws.freeze_panes = "A2" long_text_markers = ("_texto", "_feedback", "justific", "trecho", "observ", "coment", "resumo", "explic") headers = {} for col_idx in range(1, ws.max_column + 1): v = ws.cell(row=1, column=col_idx).value if v is not None: headers[str(v)] = col_idx wrap_align = Alignment(wrap_text=True, vertical="top", horizontal="left") normal_align = Alignment(wrap_text=False, vertical="top", horizontal="left") max_rows = min(ws.max_row, 5000) for header, col_idx in headers.items(): h = str(header).lower() is_long = any(m in h for m in long_text_markers) col_letter = ws.cell(row=1, column=col_idx).column_letter ws.column_dimensions[col_letter].width = min( EXCEL_TEXT_COL_W if is_long else EXCEL_DEFAULT_COL_W, EXCEL_MAX_COL_W, ) if EXCEL_WRAP_TEXT: for r in range(1, max_rows + 1): cell = ws.cell(row=r, column=col_idx) cell.alignment = wrap_align if is_long else normal_align ws.row_dimensions[1].height = 22 out = BytesIO() wb.save(out) return out.getvalue() def excel_bytes_to_df(excel_bytes: bytes) -> pd.DataFrame: bio = io.BytesIO(excel_bytes) return pd.read_excel(bio) def _safe_df(df: pd.DataFrame) -> pd.DataFrame: if df is None or df.empty: return df df = df.copy() ren = {"filename": "arquivo", "file": "arquivo"} for k, v in ren.items(): if k in df.columns and v not in df.columns: df.rename(columns={k: v}, inplace=True) if "arquivo" not in df.columns: df["arquivo"] = "" return df # ============================== # üåê Conectividade (discreta) # ============================== @st.cache_data(ttl=8) def _health_cached(url: str) -> bool: try: r = requests.get(f"{url}/health", timeout=(3, 6)) return r.status_code == 200 except Exception: return False def service_ok() -> bool: if st.session_state.get("processing"): return True return _health_cached(BASE_URL) # ============================== # üåê Chamada principal # ============================== def run_remote_file(file_bytes: bytes, filename: str, mime: str) -> Tuple[bytes, str]: files = {"file": (filename, file_bytes, mime)} headers = {"X-API-KEY": API_KEY} r = requests.post( f"{BASE_URL}/run", files=files, headers=headers, timeout=REQ_TIMEOUT, ) r.raise_for_status() run_id = r.headers.get("X-Run-Id", "") or "" return r.content, run_id # ============================== # üì¶ ZIP helpers (somente local) # ============================== def zip_extract_all(zip_bytes: bytes) -> Dict[str, bytes]: out: Dict[str, bytes] = {} bio = io.BytesIO(zip_bytes) with zipfile.ZipFile(bio, "r") as z: for name in z.namelist(): try: out[name] = z.read(name) except Exception: pass return out def pick_excels(files_map: Dict[str, bytes]) -> List[Tuple[str, bytes]]: excels = [(k, v) for k, v in files_map.items() if k.lower().endswith(".xlsx")] if not excels: return [] def _score(name: str) -> int: n = name.lower() if "spin_resultados_lote" in n: return 0 if n.endswith("_spin.xlsx") or "_spin" in n: return 1 return 2 excels.sort(key=lambda kv: (_score(kv[0]), kv[0])) return excels # ============================== # üßæ Resumo amig√°vel # ============================== def summarize_excel(df: pd.DataFrame) -> str: if df is None or df.empty: return "A planilha foi gerada, mas n√£o consegui abrir a visualiza√ß√£o aqui. Fa√ßa o download para conferir." cols = [str(c).strip() for c in df.columns] phase_cols = [c for c in cols if c.lower().startswith("check_") or re.match(r"^p[0-4]", c.lower())] if not phase_cols: return "Planilha gerada com sucesso. Use as colunas do relat√≥rio para interpretar os resultados." try: dfn = df[phase_cols].apply(pd.to_numeric, errors="coerce").fillna(0) total = float(dfn.sum().sum()) if total == 0.0: return "A planilha foi gerada, mas as etapas ficaram zeradas neste arquivo. Isso pode acontecer em conversas curtas ou sem evid√™ncias claras." return "As etapas aparecem na planilha. Use as colunas de etapas e justificativas (quando houver) para validar." except Exception: return "As colunas de etapas aparecem na planilha. Revise as colunas e justificativas para validar o resultado." # ============================== # ‚è≥ Progresso elegante (sem caixas gigantes) # ============================== def run_with_progress(phases: List[str], target_func, estimate_total_sec: Optional[float] = None): ss = st.session_state ss["processing"] = True ss["run_token"] = uuid.uuid4().hex ss["run_started_at"] = time.time() wrap = st.container() with wrap: st.markdown( """ <div class="card"> <div class="kicker">Em andamento</div> <div class="title">Processando sua solicita√ß√£o</div> <div class="muted">Acompanhe o andamento abaixo.</div> </div> """, unsafe_allow_html=True, ) phase_line = st.empty() pbar = st.progress(0) timer_line = st.empty() holder = {"ok": False, "value": None, "error": None} t0 = time.time() def _worker(): try: val = target_func() holder["ok"] = True holder["value"] = val except Exception as e: holder["error"] = e th = threading.Thread(target=_worker, daemon=True) th.start() last_idx = -1 n = max(1, len(phases)) while th.is_alive(): elapsed = time.time() - t0 if estimate_total_sec and estimate_total_sec > 2: p = min(0.92, elapsed / max(estimate_total_sec, 1.0)) else: p = min(0.85, elapsed / 120.0) pbar.progress(max(0.01, float(p))) if estimate_total_sec and estimate_total_sec > 2: frac = min(0.999, elapsed / estimate_total_sec) else: frac = min(0.999, p / 0.92) idx = min(n - 1, int(frac * n)) if idx != last_idx: phase_line.markdown( f"<div class='smallline'>‚Ä¢ {phases[idx]}</div>", unsafe_allow_html=True, ) last_idx = idx timer_line.markdown( f"<div class='smallline'>‚è±Ô∏è Tempo decorrido: <b>{human_time(elapsed)}</b></div>", unsafe_allow_html=True, ) time.sleep(0.15) elapsed = time.time() - t0 pbar.progress(1.0) time.sleep(0.05) wrap.empty() ss["processing"] = False ss["run_token"] = "" ss["run_started_at"] = 0.0 if not holder["ok"]: raise holder["error"] return holder["value"], float(elapsed) def _ema_update(key: str, x: float, alpha: float = 0.25): old = st.session_state.get(key) if old is None: st.session_state[key] = float(x) else: st.session_state[key] = float(alpha * x + (1 - alpha) * float(old)) # ============================== # ‚úÖ Execu√ß√£o: Individual (TXT/WAV) # ============================== def run_single_txt(txt: str) -> None: ok, msg = validar_transcricao(txt) if not ok: st.warning(msg) return fname = f"avaliacao_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt" est = st.session_state.get("ema_txt_sec") phases = ["Preparando‚Ä¶", "Enviando‚Ä¶", "Analisando‚Ä¶", "Gerando planilha‚Ä¶", "Finalizando‚Ä¶"] def _do(): zip_bytes, run_id = run_remote_file(txt.encode("utf-8", errors="ignore"), fname, "text/plain") return zip_bytes, run_id try: (zip_bytes, run_id), elapsed = run_with_progress(phases, _do, estimate_total_sec=est) except requests.exceptions.ConnectTimeout: st.error("N√£o consegui iniciar agora. Tente novamente em instantes.") return except requests.exceptions.ReadTimeout: st.error("Demorou mais do que o esperado. Tente um conte√∫do menor ou tente novamente.") return except requests.exceptions.HTTPError: st.error("N√£o foi poss√≠vel concluir. Tente novamente em instantes.") return except Exception: st.error("N√£o foi poss√≠vel concluir a avalia√ß√£o. Tente novamente.") return _ema_update("ema_txt_sec", elapsed) files_map = zip_extract_all(zip_bytes) excels = pick_excels(files_map) if not excels: st.error("Conclu√≠ a execu√ß√£o, mas n√£o encontrei a planilha de resultado. Tente novamente.") return main_name, main_xlsx = excels[0] main_xlsx_fmt = format_excel_bytes(main_xlsx) try: df = _safe_df(excel_bytes_to_df(main_xlsx_fmt)) except Exception: df = pd.DataFrame() payload = { "type": "single", "kind": "txt", "run_id": run_id, "source_name": fname, "excel_name": main_name, "excel_bytes": main_xlsx_fmt, "df": df, "timings": {"audio_sec": 0.0, "total_sec": float(elapsed)}, "created_at": time.time(), } clear_single() st.session_state["single_result_id"] = _store_put(payload) def run_single_wav(wav_file) -> None: wav_bytes = wav_file.getbuffer().tobytes() audio_sec = duracao_wav_seg_bytes(wav_bytes) if audio_sec and audio_sec > 600: st.warning("Este √°udio parece ter mais de 10 minutos. Pode levar mais tempo para concluir.") est = st.session_state.get("ema_wav_sec") phases = ["Preparando‚Ä¶", "Enviando‚Ä¶", "Transcrevendo‚Ä¶", "Analisando‚Ä¶", "Gerando planilha‚Ä¶", "Finalizando‚Ä¶"] def _do(): zip_bytes, run_id = run_remote_file(wav_bytes, wav_file.name, "audio/wav") return zip_bytes, run_id try: (zip_bytes, run_id), elapsed = run_with_progress(phases, _do, estimate_total_sec=est) except requests.exceptions.ConnectTimeout: st.error("N√£o consegui iniciar agora. Tente novamente em instantes.") return except requests.exceptions.ReadTimeout: st.error("Demorou mais do que o esperado. Tente novamente.") return except requests.exceptions.HTTPError: st.error("N√£o foi poss√≠vel concluir. Tente novamente em instantes.") return except Exception: st.error("N√£o foi poss√≠vel concluir a avalia√ß√£o. Tente novamente.") return _ema_update("ema_wav_sec", elapsed) files_map = zip_extract_all(zip_bytes) excels = pick_excels(files_map) if not excels: st.error("Conclu√≠ a execu√ß√£o, mas n√£o encontrei a planilha de resultado. Tente novamente.") return main_name, main_xlsx = excels[0] main_xlsx_fmt = format_excel_bytes(main_xlsx) try: df = _safe_df(excel_bytes_to_df(main_xlsx_fmt)) except Exception: df = pd.DataFrame() payload = { "type": "single", "kind": "wav", "run_id": run_id, "source_name": wav_file.name, "excel_name": main_name, "excel_bytes": main_xlsx_fmt, "df": df, "timings": {"audio_sec": float(audio_sec or 0.0), "total_sec": float(elapsed)}, "created_at": time.time(), } clear_single() st.session_state["single_result_id"] = _store_put(payload) # ============================== # ‚úÖ Execu√ß√£o: Lote (TXT/WAV) com limites novos # ============================== MAX_BATCH_WAV_FILES = 5 MAX_BATCH_WAV_SECONDS = 600 # 10 min MAX_BATCH_TXT_ENTRIES = 8 # arquivos + blocos colados def _batch_limits_card(kind: str): if kind == "wav": msg = f"√Åudio: at√© {MAX_BATCH_WAV_FILES} arquivos ‚Ä¢ at√© 10 minutos cada" else: msg = f"Texto: at√© {MAX_BATCH_TXT_ENTRIES} entradas no total (arquivos + blocos colados)" st.markdown( f""" <div class="card-tight"> <div class="kicker">Limites do lote</div> <div class="smallline">{msg}</div> </div> """, unsafe_allow_html=True, ) def run_batch_txt(files: List[Any], pasted_blocks: List[str]) -> None: entradas: List[Tuple[str, str]] = [] if files: for f in files: if len(entradas) >= MAX_BATCH_TXT_ENTRIES: break try: entradas.append((f.name, f.getvalue().decode("utf-8", errors="ignore"))) except Exception: entradas.append((f.name, "")) if pasted_blocks: for i, b in enumerate(pasted_blocks, start=1): if len(entradas) >= MAX_BATCH_TXT_ENTRIES: break entradas.append((f"colado_{i}.txt", b)) if not entradas: st.warning("Envie arquivos de texto ou cole pelo menos um bloco.") return if len(entradas) > MAX_BATCH_TXT_ENTRIES: st.warning(f"Para lote em texto, use at√© {MAX_BATCH_TXT_ENTRIES} entradas no total.") return for name, txt in entradas: ok, msg = validar_transcricao(txt) if not ok: st.warning(f"‚Ä¢ {name}: {msg}") return est_item = st.session_state.get("ema_batch_item_sec") est_total = (est_item * len(entradas)) if est_item else None phases = ["Preparando‚Ä¶", "Enviando itens‚Ä¶", "Analisando lote‚Ä¶", "Consolidando‚Ä¶", "Finalizando‚Ä¶"] def _do(): itens: List[dict] = [] lote_excel_payload = None for idx, (name, txt) in enumerate(entradas, start=1): zip_bytes, run_id = run_remote_file(txt.encode("utf-8", errors="ignore"), name, "text/plain") files_map = zip_extract_all(zip_bytes) excels = pick_excels(files_map) chosen = None for nm, xb in excels: if nm.lower().endswith("_spin.xlsx") or "_spin" in nm.lower(): chosen = (nm, xb) break if not chosen and excels: chosen = excels[0] indiv_name, indiv_xlsx_fmt = "", b"" if chosen: indiv_name, indiv_xlsx = chosen indiv_xlsx_fmt = format_excel_bytes(indiv_xlsx) itens.append( { "idx": idx, "kind": "txt", "filename": name, "run_id": run_id, "excel_individual_name": indiv_name, "excel_individual_bytes": indiv_xlsx_fmt, } ) for nm, xb in excels: if "spin_resultados_lote" in nm.lower(): lote_excel_payload = (nm, format_excel_bytes(xb)) break return itens, lote_excel_payload try: (itens, lote_excel_payload), elapsed = run_with_progress(phases, _do, estimate_total_sec=est_total) except Exception: st.error("N√£o foi poss√≠vel concluir o lote. Tente novamente em instantes.") return if len(entradas) > 0: _ema_update("ema_batch_item_sec", elapsed / max(1, len(entradas))) lote_df = pd.DataFrame() lote_name = "" lote_bytes = b"" if lote_excel_payload: lote_name, lote_bytes = lote_excel_payload try: lote_df = _safe_df(excel_bytes_to_df(lote_bytes)) except Exception: lote_df = pd.DataFrame() payload = { "type": "batch", "kind": "txt", "count": len(entradas), "created_at": time.time(), "lote": {"excel_name": lote_name, "excel_bytes": lote_bytes, "df": lote_df}, "items": itens, "timings": {"total_sec": float(elapsed)}, } clear_batch() st.session_state["batch_result_id"] = _store_put(payload) def run_batch_wav(wavs: List[Any]) -> None: if not wavs: st.warning("Envie pelo menos 1 √°udio para continuar.") return if len(wavs) > MAX_BATCH_WAV_FILES: st.warning(f"Para lote em √°udio, envie at√© {MAX_BATCH_WAV_FILES} arquivos.") return for wf in wavs: try: sec = duracao_wav_seg_bytes(wf.getbuffer().tobytes()) except Exception: sec = 0.0 if sec and sec > MAX_BATCH_WAV_SECONDS: st.warning(f"‚Ä¢ {wf.name}: acima de 10 minutos. Ajuste o arquivo e tente novamente.") return est_item = st.session_state.get("ema_batch_item_sec") est_total = (est_item * len(wavs)) if est_item else None phases = ["Preparando‚Ä¶", "Enviando itens‚Ä¶", "Analisando‚Ä¶", "Consolidando‚Ä¶", "Finalizando‚Ä¶"] def _do(): itens: List[dict] = [] lote_excel_payload = None for idx, wavf in enumerate(wavs, start=1): wav_bytes = wavf.getbuffer().tobytes() zip_bytes, run_id = run_remote_file(wav_bytes, wavf.name, "audio/wav") files_map = zip_extract_all(zip_bytes) excels = pick_excels(files_map) chosen = None for nm, xb in excels: if nm.lower().endswith("_spin.xlsx") or "_spin" in nm.lower(): chosen = (nm, xb) break if not chosen and excels: chosen = excels[0] indiv_name, indiv_xlsx_fmt = "", b"" if chosen: indiv_name, indiv_xlsx = chosen indiv_xlsx_fmt = format_excel_bytes(indiv_xlsx) itens.append( { "idx": idx, "kind": "wav", "filename": wavf.name, "run_id": run_id, "excel_individual_name": indiv_name, "excel_individual_bytes": indiv_xlsx_fmt, } ) for nm, xb in excels: if "spin_resultados_lote" in nm.lower(): lote_excel_payload = (nm, format_excel_bytes(xb)) break return itens, lote_excel_payload try: (itens, lote_excel_payload), elapsed = run_with_progress(phases, _do, estimate_total_sec=est_total) except Exception: st.error("N√£o foi poss√≠vel concluir o lote. Tente novamente em instantes.") return if len(wavs) > 0: _ema_update("ema_batch_item_sec", elapsed / max(1, len(wavs))) lote_df = pd.DataFrame() lote_name = "" lote_bytes = b"" if lote_excel_payload: lote_name, lote_bytes = lote_excel_payload try: lote_df = _safe_df(excel_bytes_to_df(lote_bytes)) except Exception: lote_df = pd.DataFrame() payload = { "type": "batch", "kind": "wav", "count": len(wavs), "created_at": time.time(), "lote": {"excel_name": lote_name, "excel_bytes": lote_bytes, "df": lote_df}, "items": itens, "timings": {"total_sec": float(elapsed)}, } clear_batch() st.session_state["batch_result_id"] = _store_put(payload) # ============================== # üß† Cabe√ßalho # ============================== st.markdown( """ <div class="card"> <div class="kicker">SPIN Analyzer</div> <div class="title">Avalia√ß√£o de liga√ß√µes e conversas de vendas</div> <p class="muted">Relat√≥rios autom√°ticos com base no m√©todo <b>SPIN Selling</b>, prontos para abrir no Excel.</p> </div> """, unsafe_allow_html=True, ) st.markdown("") # ============================== # üß≠ Sidebar (sem termos t√©cnicos) # ============================== with st.sidebar: st.markdown("### Navega√ß√£o") nav_disabled = st.session_state.get("processing", False) if st.button("üë§ Avalia√ß√£o Individual", use_container_width=True, disabled=nav_disabled): if st.session_state["view"] != "single": clear_batch() st.session_state["view"] = "single" st.rerun() if st.button("üìä Vis√£o Gerencial", use_container_width=True, disabled=nav_disabled): if st.session_state["view"] != "batch": clear_single() st.session_state["view"] = "batch" st.rerun() st.markdown("---") if service_ok(): st.success("Conectado ‚úÖ") else: st.warning("Indispon√≠vel no momento ‚ö†Ô∏è") st.markdown("---") if st.button("üßπ Limpar resultados", use_container_width=True, disabled=nav_disabled): clear_all() st.rerun() # ============================== # ‚úÖ Tela: Individual # ============================== if st.session_state["view"] == "single": st.markdown( """ <div class="card"> <div class="kicker">Avalia√ß√£o Individual</div> <div class="title">Envie um texto ou um √°udio</div> <p class="muted">Voc√™ ver√° a planilha pronta na tela e poder√° baixar em seguida.</p> </div> """, unsafe_allow_html=True, ) single_mode = st.radio( "Tipo de entrada", options=["txt", "wav"], format_func=lambda x: "üìù Texto" if x == "txt" else "üéß √Åudio (WAV)", horizontal=True, key="radio_single_mode", disabled=st.session_state.get("processing", False), ) if single_mode != st.session_state.get("single_mode"): clear_single() st.session_state["single_mode"] = single_mode if single_mode == "txt": st.markdown( "<div class='smallline'>Dica: inicie as falas com <b>[VENDEDOR]</b> e <b>[CLIENTE]</b>.</div>", unsafe_allow_html=True, ) txt_input = st.text_area( "Cole a conversa aqui", height=260, value="", key="txt_input_single", placeholder="[VENDEDOR] ...\n[CLIENTE] ...\n[VENDEDOR] ...", disabled=st.session_state.get("processing", False), ) c1, c2 = st.columns(2) with c1: if st.button("‚úÖ Iniciar", use_container_width=True, disabled=st.session_state.get("processing", False)): clear_single() run_single_txt(txt_input) with c2: if st.button("üßπ Limpar", use_container_width=True, disabled=st.session_state.get("processing", False)): clear_single() st.rerun() else: up_wav = st.file_uploader( "Envie um arquivo WAV", type=["wav"], accept_multiple_files=False, key="uploader_wav_single", disabled=st.session_state.get("processing", False), ) c1, c2 = st.columns(2) with c1: if st.button("‚úÖ Iniciar", use_container_width=True, disabled=st.session_state.get("processing", False)): if up_wav is None: st.warning("Envie um arquivo WAV para continuar.") else: clear_single() run_single_wav(up_wav) with c2: if st.button("üßπ Limpar", use_container_width=True, disabled=st.session_state.get("processing", False)): clear_single() st.rerun() # ============================== # ‚úÖ Tela: Lote # ============================== else: st.markdown( """ <div class="card"> <div class="kicker">Vis√£o Gerencial</div> <div class="title">Analise v√°rios itens de uma vez</div> <p class="muted">Ao final, voc√™ ter√° um Excel consolidado e tamb√©m uma planilha por item.</p> </div> """, unsafe_allow_html=True, ) batch_mode = st.radio( "Tipo de entrada", options=["txt", "wav"], format_func=lambda x: "üìù Texto" if x == "txt" else "üéß √Åudio (WAV)", horizontal=True, key="radio_batch_mode", disabled=st.session_state.get("processing", False), ) if batch_mode != st.session_state.get("batch_mode"): clear_batch() st.session_state["batch_mode"] = batch_mode _batch_limits_card(batch_mode) if batch_mode == "txt": st.markdown( "<div class='smallline'>Dica: inicie as falas com <b>[VENDEDOR]</b> e <b>[CLIENTE]</b>.</div>", unsafe_allow_html=True, ) up_txts = st.file_uploader( "Envie arquivos .txt", type=["txt"], accept_multiple_files=True, key="uploader_txt_batch", disabled=st.session_state.get("processing", False), ) st.markdown("<div class='smallline'>Ou cole v√°rios blocos (separe com uma linha contendo <b>---</b>).</div>", unsafe_allow_html=True) multi_txt = st.text_area( "Cole aqui", height=220, value="", key="txt_input_batch", placeholder="[VENDEDOR] ...\n[CLIENTE] ...\n---\n[VENDEDOR] ...\n[CLIENTE] ...", disabled=st.session_state.get("processing", False), ) c1, c2 = st.columns(2) with c1: if st.button("‚úÖ Iniciar lote", use_container_width=True, disabled=st.session_state.get("processing", False)): blocks = [] if multi_txt.strip(): blocks = [b.strip() for b in multi_txt.split("\n---\n") if b.strip()] clear_batch() run_batch_txt(up_txts or [], blocks) with c2: if st.button("üßπ Limpar", use_container_width=True, disabled=st.session_state.get("processing", False)): clear_batch() st.rerun() else: up_wavs = st.file_uploader( "Envie arquivos WAV", type=["wav"], accept_multiple_files=True, key="uploader_wav_batch", disabled=st.session_state.get("processing", False), ) c1, c2 = st.columns(2) with c1: if st.button("‚úÖ Iniciar lote", use_container_width=True, disabled=st.session_state.get("processing", False)): clear_batch() run_batch_wav(up_wavs or []) with c2: if st.button("üßπ Limpar", use_container_width=True, disabled=st.session_state.get("processing", False)): clear_batch() st.rerun() # ============================== # ‚úÖ RESULTADO: Individual (somente Excel) # ============================== single_payload = _store_get(st.session_state.get("single_result_id", "")) if single_payload and single_payload.get("type") == "single": st.markdown("") st.markdown( """ <div class="card"> <div class="kicker">Resultado</div> <div class="title">Planilha pronta para revis√£o</div> </div> """, unsafe_allow_html=True, ) run_id = single_payload.get("run_id", "") kind = single_payload.get("kind", "") src = single_payload.get("source_name", "") badges = [] badges.append("<span class='badge badge-ok'>üéß √Åudio</span>" if kind == "wav" else "<span class='badge badge-ok'>üìù Texto</span>") if run_id: badges.append(f"<span class='badge badge-brand'>Protocolo: {run_id}</span>") if src: badges.append(f"<span class='badge'>Arquivo: {Path(src).name}</span>") st.markdown( f"<div class='card-tight'><div class='badges'>{''.join(badges)}</div></div>", unsafe_allow_html=True, ) df = single_payload.get("df", pd.DataFrame()) st.markdown("") st.markdown("<div class='card-tight'><div class='title'>üìä Visualiza√ß√£o</div><p class='muted'>Abaixo est√° a planilha aberta para consulta r√°pida.</p></div>", unsafe_allow_html=True) st.dataframe(df, use_container_width=True) timings = single_payload.get("timings", {}) or {} audio_sec = float(timings.get("audio_sec", 0) or 0) total_sec = float(timings.get("total_sec", 0) or 0) st.markdown( f""" <div class="card-tight"> <div class="title">‚è±Ô∏è Tempo</div> <div class="badges" style="margin-top:8px;"> <span class="badge">Dura√ß√£o: <b>{human_time(audio_sec)}</b></span> <span class="badge">Processamento: <b>{human_time(total_sec)}</b></span> </div> </div> """, unsafe_allow_html=True, ) st.markdown( f""" <div class="card-tight"> <div class="title">üìå Observa√ß√£o</div> <p class="muted">{summarize_excel(df)}</p> </div> """, unsafe_allow_html=True, ) base = Path(single_payload.get("source_name") or "avaliacao").stem excel_bytes = single_payload.get("excel_bytes", b"") st.markdown("") st.download_button( "üì• Baixar Excel", data=excel_bytes, file_name=f"{base}_avaliacao.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", use_container_width=True, key=f"dl_single_excel_{base}_{single_payload.get('created_at',0)}", ) # ============================== # ‚úÖ RESULTADO: Lote (somente Excel) # ============================== batch_payload = _store_get(st.session_state.get("batch_result_id", "")) if batch_payload and batch_payload.get("type") == "batch": st.markdown("") st.markdown( """ <div class="card"> <div class="kicker">Resultados do lote</div> <div class="title">Consolidado + itens individuais</div> <p class="muted">Baixe o Excel do lote e, se quiser, uma planilha por item.</p> </div> """, unsafe_allow_html=True, ) lote = batch_payload.get("lote", {}) or {} lote_df = lote.get("df", pd.DataFrame()) lote_bytes = lote.get("excel_bytes", b"") if isinstance(lote_df, pd.DataFrame) and not lote_df.empty: st.markdown("<div class='card-tight'><div class='title'>üìä Planilha do lote (aberta)</div></div>", unsafe_allow_html=True) st.dataframe(lote_df, use_container_width=True) else: st.markdown("<div class='card-tight'><div class='title'>üìä Planilha do lote</div><p class='muted'>Use o download abaixo para abrir no Excel.</p></div>", unsafe_allow_html=True) st.markdown("") if lote_bytes: st.download_button( "üì• Baixar Excel do lote", data=lote_bytes, file_name=f"lote_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", use_container_width=True, key=f"dl_lote_excel_{batch_payload.get('created_at',0)}", ) items = batch_payload.get("items", []) or [] st.markdown("") st.markdown("<div class='card-tight'><div class='title'>üìÅ Itens</div><p class='muted'>Expanda para baixar a planilha individual.</p></div>", unsafe_allow_html=True) for item in items: idx = item.get("idx", 0) filename = str(item.get("filename") or f"item_{idx}") base = Path(filename).stem with st.expander(f"{idx}. {filename}", expanded=False): xb = item.get("excel_individual_bytes", b"") or b"" if xb: st.download_button( "üì• Baixar Excel (individual)", data=xb, file_name=f"{base}_avaliacao.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", use_container_width=True, key=f"dl_item_excel_{idx}_{base}_{batch_payload.get('created_at',0)}", ) else: st.info("Planilha individual n√£o dispon√≠vel para este item.") # ============================== # üßæ Rodap√© # ============================== st.markdown("") st.markdown( "<div style='text-align:center;color:#4B5A74;font-weight:650;'>SPIN Analyzer ‚Äî Projeto Tele_IA 2026</div>", unsafe_allow_html=True, )
